{
  "cells": [
    {
      "metadata": {
        "_uuid": "027a53392672d0bb79b0f553e6897c6df6124551"
      },
      "cell_type": "markdown",
      "source": "# Data Analysis & Regularized Linear Regression "
    },
    {
      "metadata": {
        "_uuid": "5853177eafbec10ae676f24e2225fe9b09767b36"
      },
      "cell_type": "markdown",
      "source": "#### In this kernel, I summed up everything I've learnt to understand this competetion and solve the problem. You will learn from this kernel how to visualize, clean and prepare the data to train you machine leanrnig model, and even select the best model for the problem with the help of the learning curves."
    },
    {
      "metadata": {
        "_uuid": "0373a3dba9548bb0a20298fbccbd5432e16b39c0"
      },
      "cell_type": "markdown",
      "source": "#### Well, what then? we need to predict the house prices and all what we have is the data! So, let's look at it to familiarize ourselves and know what is needed to be done to prepare the data for the machine learning part. \n\n**Get motivated and believe me after this kernel you will have superpowers!... along with some fun! **"
    },
    {
      "metadata": {
        "_uuid": "8f2839f25d086af736a60e9eeb907d3b93b6e0e5",
        "_cell_guid": "b1076dfc-b9ad-4769-8c92-a6c4dae69d19",
        "trusted": true,
        "collapsed": true
      },
      "cell_type": "markdown",
      "source": "Let's import first some libraries."
    },
    {
      "metadata": {
        "_cell_guid": "79c7e3d0-c299-4dcb-8224-4455121ee9b0",
        "collapsed": true,
        "_uuid": "d629ff2d2480ee46fbb7e2d37f6b5fab8052498a",
        "trusted": true
      },
      "cell_type": "code",
      "source": "import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom scipy import stats\nfrom scipy.stats import norm\n\nimport warnings\ndef ignore_warn(*args, **kwargs):\n    pass\nwarnings.warn = ignore_warn #ignore annoying warning (from sklearn and seaborn)\nfrom scipy.stats import skew",
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "_uuid": "25a5d365996c9648cc0ae6f2c281cc9be5d118a0"
      },
      "cell_type": "markdown",
      "source": "And load the data which is splitted into two files, one for** trianing** and another for **testing**."
    },
    {
      "metadata": {
        "trusted": true,
        "_uuid": "e9f9a2f11b21af416a89daf0f089ce398f6fb073",
        "collapsed": true
      },
      "cell_type": "code",
      "source": "X_train = pd.read_csv('../input/train.csv')\nX_test = pd.read_csv('../input/test.csv')",
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "collapsed": true,
        "_uuid": "21dc1acf4d0ac2c161bc06563fc1941f4a41de4e"
      },
      "cell_type": "markdown",
      "source": "Nice, we have the data. Let's have a quick look at it."
    },
    {
      "metadata": {
        "trusted": true,
        "_uuid": "0c5549fdb141f5623b05c050f7ccef5b0b3dd582",
        "collapsed": true
      },
      "cell_type": "code",
      "source": "X_train.head()",
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "_uuid": "eac637cea2731dc38185333bdeb075aeb985ca6c"
      },
      "cell_type": "markdown",
      "source": "So, we now know a little bit about our data(contains **categorical features**), and need to go deep! Let's get more info about our features(columns)."
    },
    {
      "metadata": {
        "trusted": true,
        "_uuid": "311c3b05692f9c880d69b4ab18693886953fd7ae",
        "collapsed": true
      },
      "cell_type": "code",
      "source": "X_train.info()",
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "_uuid": "6ca15a527c248717e14fc8b485d6f64e0685da73"
      },
      "cell_type": "markdown",
      "source": "We have 81 features(columns) of types object(43), int(35), and float(3), and with a closer look you will notice that some of them have missing values(the non- null values aren't 1460). So, along with the **categorical columns**, we will need to handle the **missing values**.\n\nLet's see how our target variable, **SalePrice**,  is correlated with some other varibles in our data."
    },
    {
      "metadata": {
        "trusted": true,
        "_uuid": "f13c520ec78d5e58d750f4738bd60c8c1f95e28a",
        "scrolled": true,
        "collapsed": true
      },
      "cell_type": "code",
      "source": "#the correlation matrix\ncorr_mat = X_train.corr()\ncorr_mat['SalePrice'].sort_values(ascending=False)\n",
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "_uuid": "dba125ac4f57fd2dfa9362c30f7669f1b0723a53"
      },
      "cell_type": "markdown",
      "source": "Awesome! let's pick the some of the **highly correlated** columns with our **SalePrice** column,  then have a scatter party, where we drink **outliers**! \n"
    },
    {
      "metadata": {
        "trusted": true,
        "scrolled": true,
        "_uuid": "a4d6ca2f1f4b495d692308d0ba1c4d04ce11e41d",
        "collapsed": true
      },
      "cell_type": "code",
      "source": "#get the variables that have a good correlation(>.7) with the target\nvalues = list(corr_mat['SalePrice'].values)\nkeys = list(corr_mat['SalePrice'].keys())\nvariables = [i for i in keys if values[keys.index(i)] > .7]\n\n#ploting scatters \nsns.set()\nsns.pairplot(X_train[variables],size=3)\nplt.show()",
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "_uuid": "09e1820c135502fc7ee1c37799f2b33a692d3e33"
      },
      "cell_type": "markdown",
      "source": "Lots of figurs? Not really LOL. \n\nDon't get lost. Look at the** 3rd row, the plot in the middle** represents the scatter** between 'SalePrice', \nand 'GrLivArea'.** Noticed something? the two points** between 4000 and 6000 on the x-axis**? these two points probably think they are diffrent\nor even smarter from their mates, but they had a bad end. They were sold with a** low price** althoug they claim they are** big areas(houses)**!  \nSo, we can't have such arrogant points in our data! They do not even go with the flow like the other two points in the top right of the graph. We will delete them! why? because **outliers** cause problems when applying **statistical tests**('regression; in this problem), and they are probably errors."
    },
    {
      "metadata": {
        "trusted": true,
        "_uuid": "a44d182c6df651c5365fffa434e8886ac4708762",
        "collapsed": true
      },
      "cell_type": "code",
      "source": "X_train.drop(X_train[(X_train['GrLivArea']>4000) & (X_train['SalePrice']<300000)].index, inplace=True)",
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "_uuid": "3c3c04213b2f9ad2310606da4dcc24c88567c7f6"
      },
      "cell_type": "markdown",
      "source": "Well, that's not everything you get from these scatters. Look at the **skewed** data( 3rd row, top right). Wait! Lets Look at it closely."
    },
    {
      "metadata": {
        "trusted": true,
        "_uuid": "79bfba515835f770c73b224080c1f799842231b8",
        "collapsed": true
      },
      "cell_type": "code",
      "source": "sns.distplot(X_train['SalePrice'], fit=norm);\nfig = plt.figure()\nres = stats.probplot(X_train['SalePrice'], plot=plt)\nplt.show()",
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "_uuid": "c70888dd44ca015d8feb611f34d2f420c2140e34"
      },
      "cell_type": "markdown",
      "source": "The **skewed data **has no justice! it either gives more money(points) to the people of the East or the West! it gives one, \nand abuse another. Such injustice! We will force it to spread its points equally using some sort of powers(**Log Transformation**).\n\nHmm, you think we're nice, right? No, Not really. We did this for our problem's sake(**regression**) Since This can be valuable both \nfor making patterns in the data more interpretable, and for helping to** meet the assumptions** of some statistical test(Regression)."
    },
    {
      "metadata": {
        "_uuid": "a18b87a158c060725150ff2954aaf8a4df7c5400"
      },
      "cell_type": "markdown",
      "source": "Yay! we're done!...knowing how to clean our data for a machine learning model!\n\nHere what we're gonna do:\n \n*  **Handling the missing data.**\n*  **Transforming the data with Log.**\n*  **Getting Dummy variables. **"
    },
    {
      "metadata": {
        "_uuid": "7b098f89d02cf84d508b20b1fd6827c13f00f67a"
      },
      "cell_type": "markdown",
      "source": "Before we carry on, let's delete our target **SalePrice**, and the **Id** column and save them for later, and concatenate the training data and test data\ntogether for a bit."
    },
    {
      "metadata": {
        "trusted": true,
        "_uuid": "a6d64799b9ff99efd32c03cb42d0137f23be7bca",
        "collapsed": true
      },
      "cell_type": "code",
      "source": "#saving the labels of our target variable \ny = X_train['SalePrice']\n\n#save the id column for later.\ntest_id = X_test['Id']\n\n#dropping column that will not be needed when training our model.\nX_train.drop('SalePrice', 1, inplace=True)\nX_train.drop(\"Id\", axis = 1, inplace = True)\nX_test.drop(\"Id\", axis = 1, inplace = True)\n\n#save indexes before concatenating\nX_train_idx = X_train.shape[0]\nX_test_idx = X_test.shape[0]\n\n#concatenate the data\ndata = pd.concat((X_train,X_test)).reset_index(drop=True)\nprint('Train index: %s \\nTest index: %s \\nShape of our whole data(rows,columns): %s'%(X_train_idx, X_test_idx, data.shape))",
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "_uuid": "40d2110ce11b4b212578cd3b3efa7c2225c2a14e",
        "collapsed": true
      },
      "cell_type": "markdown",
      "source": "Very good!\n\nNow we handle the **missing data**."
    },
    {
      "metadata": {
        "trusted": true,
        "_uuid": "14989d1ad08b96d01de8bc8167792a1bdbbe1a78",
        "collapsed": true
      },
      "cell_type": "code",
      "source": "#print the sum of the missing values of a column from the highest to the lowest.\nnumeric_cols = []\nnon_numeric_cols = []\nfor key,val in data.isnull().sum().sort_values(ascending=False).items():\n    if val > 0:\n        print(key, val, data[key].dtype)\n        if data[key].dtype != 'object':numeric_cols.append(key)\n        elif data[key].dtype == 'object':non_numeric_cols.append(key)\n        ",
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "_uuid": "272b4390f39c5184a160d2a26e0ec6aa544b3813"
      },
      "cell_type": "markdown",
      "source": "Well, it seems that some of the columns are **numeric** and others not so, let's look at the **non-numeric** first."
    },
    {
      "metadata": {
        "trusted": true,
        "scrolled": true,
        "_uuid": "82c954f277fa1363dc2f552868a66b14a033f26d",
        "collapsed": true
      },
      "cell_type": "code",
      "source": "features = data.isnull().sum().sort_values(ascending=False).keys()\nmissing_values = pd.DataFrame(data[numeric_cols])\nmissing_values.head()",
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "collapsed": true,
        "_uuid": "0771c5107a453bb763232866dec97b44c4d9a176"
      },
      "cell_type": "markdown",
      "source": "We will fill the missing values for **BsmtHalfBath, BsmtFullBath, BsmtFinSF2, GarageCars** with zero because I can see that some of the \ninstances have zero also which mean that instance(house) has no value for that feature(Bsmt)\n\nWe fill the missing values for **GarageArea,TotalBsmtSF, MasVnrArea, GarageYrBlt, BsmtFinSF1, LotFrontage, BsmtUnfSF** with the median of each column since the missing\nvalue could've just been a close number to its friends."
    },
    {
      "metadata": {
        "trusted": true,
        "_uuid": "8ea9758540b1779ce308dfefdd5827ded34f422f",
        "scrolled": true,
        "collapsed": true
      },
      "cell_type": "code",
      "source": "fill_zero_cols = ['BsmtHalfBath', 'BsmtFullBath', 'BsmtFinSF2', 'GarageCars']\nfill_median_cols = ['GarageArea','TotalBsmtSF', 'MasVnrArea', 'BsmtFinSF1', 'LotFrontage', 'BsmtUnfSF', 'GarageYrBlt']\n[data[i].fillna(0,inplace=True) for i in fill_zero_cols]\n[data[j].fillna(data[j].median(),inplace=True) for j in fill_median_cols];",
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "_uuid": "4a2a055984229195c75ed748f474747563be56b8"
      },
      "cell_type": "markdown",
      "source": "\nTime to fill in the **non-numeric **ones."
    },
    {
      "metadata": {
        "trusted": true,
        "_uuid": "87b5721bd34c6c0205ba631b349dc4c426a34da7",
        "collapsed": true
      },
      "cell_type": "code",
      "source": "features = data.isnull().sum().sort_values(ascending=False).keys()\nmissing_values = pd.DataFrame(data[non_numeric_cols])\nmissing_values.head()",
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "_uuid": "ff98ee0384069ebeaab8915ed0cb20c5b232aa07"
      },
      "cell_type": "markdown",
      "source": "Okay, so most of these features are yes-no questions, for instance, to fill the missing values for the feature 'PoolQC' you have \nto ask yourself this question '**Does the following house have a pool?**'. Therefore, We're gonna fill the** missing values** with 'none'\nmeaning that the following house doesn't have that feature. Fun! Let's none these values."
    },
    {
      "metadata": {
        "trusted": true,
        "_uuid": "64f81df150790259d8ab63bc994b080163c49ce1",
        "collapsed": true
      },
      "cell_type": "code",
      "source": "data.fillna('none', inplace=True)",
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "_uuid": "e11048b59a53a2ded290f3d8a0b0fc52ff618417"
      },
      "cell_type": "markdown",
      "source": "That was super fast LOL. Let's check again to make sure we don't have missing values."
    },
    {
      "metadata": {
        "trusted": true,
        "_uuid": "b584e00ba5c9b378ea17b042728b11472d28febe",
        "collapsed": true
      },
      "cell_type": "code",
      "source": "data.isnull().sum().sort_values(ascending=False)",
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "_uuid": "d6e44fb871e3cbd5e216c0415d72b1bbcb71a6c2"
      },
      "cell_type": "markdown",
      "source": "Hip hip! we're are done. NO MISSING VALUES! Now, we take care of our categorical columns.\n\nTime to bring justice to the East and West of our data, and handle the skewed data with the** Log** power! "
    },
    {
      "metadata": {
        "trusted": true,
        "_uuid": "421f3cb7061f4c3cbb7ff867b00394bd64052f13",
        "collapsed": true
      },
      "cell_type": "code",
      "source": "#transforming our target labels(SalePrice).\ny = np.log1p(y)\n#transfomring the numeric features \nnumeric_feats = data.dtypes[data.dtypes != \"object\"].index\nskewed_feats = X_train[numeric_feats].apply(lambda x: skew(x.dropna())) #compute skewness\nskewed_feats = skewed_feats[skewed_feats > 0.75]\nskewed_feats = skewed_feats.index\ndata[skewed_feats] = np.log1p(data[skewed_feats])",
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "_uuid": "986833e407a9ccaa308d1cebbe84ffbbc637bb7e"
      },
      "cell_type": "markdown",
      "source": "We're finally have our data ready for our models, but we need to **get_dummies** for our **categorical features** first because the models need numbers not categories.\n\nFor Example, the feature 'PoolQC' is a categorical feature. it's filled with 4 values, (Ex, none,..etc)  when we get dummies for it. the following will happen:"
    },
    {
      "metadata": {
        "trusted": true,
        "_uuid": "59628152acda5955e8fe2f8c4ec1d33cefe29162",
        "collapsed": true
      },
      "cell_type": "code",
      "source": "pd.get_dummies(data['PoolQC']).head()",
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "_uuid": "fc336feec469f9e0998a45e4c8d78a29530695eb"
      },
      "cell_type": "markdown",
      "source": "As you see above, each category will be a column(feature) and will be 1 if the following instance has that feature and 0 if it has not.\nSo, let's do this to all the data."
    },
    {
      "metadata": {
        "trusted": true,
        "_uuid": "08ce946574d0bcebaac742bd022c4a2ebac1860b",
        "collapsed": true
      },
      "cell_type": "code",
      "source": "data = pd.get_dummies(data)",
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "_uuid": "52604d6ed552ec24979dd788460e2c56db8ee4de"
      },
      "cell_type": "markdown",
      "source": "**Models**"
    },
    {
      "metadata": {
        "_uuid": "f29ee58e98a4710b69025c478007d77cf7e0c098"
      },
      "cell_type": "markdown",
      "source": "We've arrived safely to the second part. Congrats!\n\nTime to seprate out train and test set since we're done processing the data."
    },
    {
      "metadata": {
        "trusted": true,
        "_uuid": "65e188b069ab2a98e8842a61e232698146b75dd5",
        "collapsed": true
      },
      "cell_type": "code",
      "source": "X_train = data[:X_train_idx]\nX_test = data[X_train_idx:] ",
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "_uuid": "f9a167393f169f2032ed9a2029e9dd69840aa79f"
      },
      "cell_type": "markdown",
      "source": "Let's import here some needed libraries."
    },
    {
      "metadata": {
        "trusted": true,
        "_uuid": "ed29c689731027b92a0a55aacfcaf2241d4c1484",
        "collapsed": true
      },
      "cell_type": "code",
      "source": "from sklearn.linear_model import Lasso, ElasticNet, Ridge\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.model_selection import cross_val_score\nfrom sklearn.preprocessing import StandardScaler",
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "_uuid": "9b71e4891ec44870ba53151966bf1d3a20d93595"
      },
      "cell_type": "markdown",
      "source": "We're going to train a lasso model.** Lasso** is simply a regularized linear regression model. Lasso also selects\nthe most important features, so it does the** feature selection** process for us. Then we will evaluate it using cross validation, and look at some learning curves as well."
    },
    {
      "metadata": {
        "trusted": true,
        "collapsed": true,
        "_uuid": "0563448b828fc82018a2673d9e256babca52c5b9"
      },
      "cell_type": "code",
      "source": "#our cross function\ndef display_scores(scores):\n    print(\"Score:{:.4f}\".format(scores.mean()))\n#learning curves function \ndef plot_learning_curves(model, X, y):\n    X_train, X_val, y_train, y_val = train_test_split(X, y, test_size=0.2)\n    train_errors, val_errors = [], []\n    for m in range(1, len(X_train)):\n        model.fit(X_train[:m], y_train[:m])\n        y_train_predict = model.predict(X_train[:m])\n        y_val_predict = model.predict(X_val)\n        train_errors.append(mean_squared_error(y_train_predict, y_train[:m]))\n        val_errors.append(mean_squared_error(y_val_predict, y_val))\n        plt.plot(np.sqrt(train_errors), \"r-+\", linewidth=2, label=\"train\")\n        plt.plot(np.sqrt(val_errors), \"b-\", linewidth=3, label=\"val\")",
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "_uuid": "486495075ec7ce888debf61d84b14e9d3629de8a"
      },
      "cell_type": "markdown",
      "source": "Let's train our **lasso model** and see how it will **score**."
    },
    {
      "metadata": {
        "trusted": true,
        "_uuid": "2376de081d2966a552f4d0735126a1d7c1ffef40",
        "collapsed": true
      },
      "cell_type": "code",
      "source": "lasso = Lasso(alpha=10).fit(X_train,y)\nscores = cross_val_score(lasso,X_train,y,scoring='neg_mean_squared_error',cv=5)\nrmse_scores = np.sqrt(-scores)\ndisplay_scores(rmse_scores)",
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "_uuid": "7c882020c5958e3ec9378e9b89b8f8d0aa8bc245"
      },
      "cell_type": "markdown",
      "source": "Well, not a bad score for the first attempt! Let's fine-tune the model and look at the **learning curve**."
    },
    {
      "metadata": {
        "trusted": true,
        "_uuid": "f31181253f7ff328a8a43b0c778f5532b1789c96",
        "collapsed": true
      },
      "cell_type": "code",
      "source": "plot_learning_curves(lasso,X_train,y)\nplt.show()",
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "_uuid": "c077b31f3ed13e068843fbf2f09d43b6f756c853"
      },
      "cell_type": "markdown",
      "source": "This time we trained our model with a** big alpha**(learning rate), so in our learning curve you see that our model is not fitting\nthe data well(the red line represents the train set, and it tells us whether our model is** overfitting or underfitting** the data).\n\nThe red line starts with error 0, meaning that our model fits the data well when it starts with some instances, but when it's given more instances,  it underfits the data. \n\nThe blue line shows how our model generalizes on the validation set, data it's never seen before. Also, in our curve we a big error on the validation set. So, our model performs poorly both on the training set and the validation set.\n\nThis happed beacuse the alpha the we trained our lasso model with is big. Alpha is resposible for this '**how much you want to regularize your model?**', so the bigger alpha, the more you model will decrease the features'coefficients to zero, and the model will be have then less features that will make it a **high bias model** or just simple model, model cannot fit the data.****"
    },
    {
      "metadata": {
        "_uuid": "813dbe0b8a98ded56635f3a6e44a94019408999d"
      },
      "cell_type": "markdown",
      "source": "Let's train our model with very** small alpha** and see what get."
    },
    {
      "metadata": {
        "trusted": true,
        "_uuid": "7d57d792591842c63ed4a072260d1b9ed70b2d91",
        "collapsed": true
      },
      "cell_type": "code",
      "source": "lasso = Lasso(alpha=.0005).fit(X_train,y)\nscores = cross_val_score(lasso,X_train,y,scoring='neg_mean_squared_error',cv=5)\nrmse_scores = np.sqrt(-scores)\ndisplay_scores(rmse_scores)",
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "_uuid": "21161723f0ae4ce7d00839ea8095c0a70a1b9d79"
      },
      "cell_type": "markdown",
      "source": "WOW! it improved! Let's look at the learning curve, hurry up! "
    },
    {
      "metadata": {
        "trusted": true,
        "collapsed": true,
        "_uuid": "73a277a4ac2a9e6f044f6cb36aeb756f9f83d6a1"
      },
      "cell_type": "code",
      "source": "plot_learning_curves(lasso,X_train,y)\nplt.show()",
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "_uuid": "2eaae07b2843c11a36ea9a22ffae04aee47d5284"
      },
      "cell_type": "markdown",
      "source": "Okay, now our model fits and generalizes better. Still we have an error on both the training set and the validation set that can\nbe improved **by feeding our model with more instances, features, or training a more complex model**. "
    },
    {
      "metadata": {
        "_uuid": "a104b4687422400f49edb43ffee65661413f80b7"
      },
      "cell_type": "markdown",
      "source": "Now, lets predict the prices and save them into a file to be submitted."
    },
    {
      "metadata": {
        "trusted": true,
        "collapsed": true,
        "_uuid": "7587454a044421b53ccde21c7a3311544a401532"
      },
      "cell_type": "code",
      "source": "preds = lasso.predict(X_test)\nprediction = pd.DataFrame(np.exp(preds), test_id, columns=['SalePrice']).to_csv('predictions.csv')",
      "execution_count": null,
      "outputs": []
    },
    {
      "metadata": {
        "_uuid": "f31defc1894da22a906e02965f77fb970ff52120"
      },
      "cell_type": "markdown",
      "source": "The kernel is over! I had fun writing this kernel and learned a lot. I hope you did as well. \n\nIf you want more if this, go check these kernels as well because they are really good and helped me a lot.\n\n*  [stacked-regressions-top-4-on-leaderboard](http://https://www.kaggle.com/serigne/stacked-regressions-top-4-on-leaderboard) \n* [comprehensive-data-exploration-with-python](http://https://www.kaggle.com/pmarcelino/comprehensive-data-exploration-with-python)\n\nThank you! \n"
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    },
    "language_info": {
      "name": "python",
      "version": "3.6.4",
      "mimetype": "text/x-python",
      "codemirror_mode": {
        "name": "ipython",
        "version": 3
      },
      "pygments_lexer": "ipython3",
      "nbconvert_exporter": "python",
      "file_extension": ".py"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 1
}
